import { describe, it, expect, vi, beforeEach } from 'vitest';
import { supabase } from '@/integrations/supabase/client';

describe('Database Triggers', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('QR Code Generation', () => {
    it('trigger_generate_member_qr: auto-generate unique QR', async () => {
      // Mock member insert without qr_code
      const mockInsert = vi.fn().mockResolvedValue({
        data: {
          id: 'member-001',
          nome: 'João Silva',
          qr_code: 'MBR-ABC12345', // Generated by trigger
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { insert: mockInsert } as any;
        }
        return {} as any;
      });

      // Insert member without qr_code
      const { data, error } = await supabase.from('members').insert({
        nome: 'João Silva',
        telefone: '912345678',
        email: 'joao@test.com',
        // qr_code NOT provided - should be generated by trigger
      });

      expect(error).toBeNull();
      expect(data?.qr_code).toMatch(/^MBR-[A-Z0-9]{8}$/);

      // Insert another member - verify QR codes are unique
      const mockInsert2 = vi.fn().mockResolvedValue({
        data: {
          id: 'member-002',
          qr_code: 'MBR-XYZ98765', // Different QR
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { insert: mockInsert2 } as any;
        }
        return {} as any;
      });

      const { data: data2 } = await supabase.from('members').insert({
        nome: 'Maria Costa',
        telefone: '918888888',
        email: 'maria@test.com',
      });

      // Verify unique QR codes
      expect(data2?.qr_code).not.toBe(data?.qr_code);
    });
  });

  describe('Payment Reference Generation', () => {
    it('trigger_generate_payment_ref: auto-generate BM- reference', async () => {
      // Mock pending_payment insert without reference
      const mockInsert = vi.fn().mockResolvedValue({
        data: {
          id: 'pending-001',
          reference: 'BM-001234', // Generated by trigger
          amount_cents: 6900,
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'pending_payments') {
          return { insert: mockInsert } as any;
        }
        return {} as any;
      });

      const { data, error } = await supabase.from('pending_payments').insert({
        member_id: 'member-123',
        amount_cents: 6900,
        payment_method: 'TRANSFERENCIA',
        status: 'PENDING',
        // reference NOT provided - should be generated
      });

      expect(error).toBeNull();
      expect(data?.reference).toMatch(/^(BM|PAY|ENR)-\d{6}$/);

      // Verify sequential numbering (next one should be +1)
      const mockInsert2 = vi.fn().mockResolvedValue({
        data: {
          id: 'pending-002',
          reference: 'BM-001235', // Sequential
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'pending_payments') {
          return { insert: mockInsert2 } as any;
        }
        return {} as any;
      });

      const { data: data2 } = await supabase.from('pending_payments').insert({
        member_id: 'member-456',
        amount_cents: 6900,
        payment_method: 'TRANSFERENCIA',
      });

      // References should be sequential
      const ref1Number = parseInt(data?.reference?.split('-')[1] || '0');
      const ref2Number = parseInt(data2?.reference?.split('-')[1] || '0');
      expect(ref2Number).toBeGreaterThanOrEqual(ref1Number);
    });
  });

  describe('Timestamp Update', () => {
    it('trigger_update_timestamp: auto-update updated_at', async () => {
      const now = new Date();
      const futureTime = new Date(now.getTime() + 1000); // 1 second later

      // Mock insert with created_at
      const mockInsert = vi.fn().mockResolvedValue({
        data: {
          id: 'member-001',
          created_at: now.toISOString(),
          updated_at: now.toISOString(),
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { insert: mockInsert } as any;
        }
        return {} as any;
      });

      const { data } = await supabase.from('members').insert({
        nome: 'João',
        telefone: '912345678',
      });

      const initialUpdatedAt = data?.updated_at;

      // Mock update
      const mockEq = vi.fn().mockResolvedValue({
        data: {
          ...data,
          updated_at: futureTime.toISOString(), // Trigger updates this
        },
        error: null,
      });

      const mockUpdate = vi.fn().mockReturnValue({ eq: mockEq });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { update: mockUpdate } as any;
        }
        return {} as any;
      });

      // Wait 1 second then update
      await new Promise(resolve => setTimeout(resolve, 100));

      const { data: updatedData } = await supabase
        .from('members')
        .update({ nome: 'João Silva' })
        .eq('id', 'member-001');

      // Verify updated_at changed
      expect(updatedData?.updated_at).not.toBe(initialUpdatedAt);
      expect(new Date(updatedData?.updated_at || '').getTime()).toBeGreaterThan(
        new Date(initialUpdatedAt || '').getTime()
      );
    });
  });

  describe('Cash Session Expected Closing', () => {
    it('trigger_update_cash_expected: recalculate on DINHEIRO transaction', async () => {
      const sessionId = 'session-001';
      const opening = 10000; // €100 opening
      const transaction1 = 5000; // €50 in
      const transaction2 = 2000; // €20 out

      // Calculate expected closing after transactions
      const expectedAfterFirst = opening + transaction1; // 10000 + 5000 = 15000
      const expectedAfterSecond = expectedAfterFirst - transaction2; // 15000 - 2000 = 13000

      // Verify manual calculation
      expect(expectedAfterFirst).toBe(15000);
      expect(expectedAfterSecond).toBe(13000);

      // Mock transaction insert (trigger would update cash session in real database)
      const mockTransactionInsert = vi.fn().mockResolvedValue({
        data: { id: 'txn-001', amount_cents: transaction1 },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'transactions') {
          return { insert: mockTransactionInsert } as any;
        }
        return {} as any;
      });

      await supabase.from('transactions').insert({
        type: 'RECEITA',
        category: 'SUBSCRIPTION',
        amount_cents: transaction1,
        payment_method: 'DINHEIRO',
        cash_session_id: sessionId,
      });

      // Verify transaction was inserted (trigger would auto-update cash_sessions)
      expect(mockTransactionInsert).toHaveBeenCalled();
    });
  });

  describe('Audit Log Trigger', () => {
    it('trigger_audit_log: log member creation', async () => {
      const mockMemberInsert = vi.fn().mockResolvedValue({
        data: { id: 'member-001', nome: 'João Silva', status: 'LEAD' },
        error: null,
      });

      const mockAuditInsert = vi.fn().mockResolvedValue({
        data: {
          id: 'audit-001',
          action: 'CREATE',
          entity_type: 'member',
          entity_id: 'member-001',
          new_value: { nome: 'João Silva', status: 'LEAD' },
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { insert: mockMemberInsert } as any;
        }
        if (table === 'audit_logs') {
          return { insert: mockAuditInsert } as any;
        }
        return {} as any;
      });

      // Insert member
      await supabase.from('members').insert({
        nome: 'João Silva',
        telefone: '912345678',
        email: 'joao@test.com',
      });

      // Trigger should create audit log entry
      // Verify audit log would be created
      expect(mockMemberInsert).toHaveBeenCalled();
      // In real implementation, trigger automatically creates audit log
    });

    it('trigger_audit_log: log member update with old/new values', async () => {
      const oldValue = { status: 'LEAD' };
      const newValue = { status: 'ATIVO' };

      const mockEq = vi.fn().mockResolvedValue({
        data: { id: 'member-001', ...newValue },
        error: null,
      });

      const mockUpdate = vi.fn().mockReturnValue({ eq: mockEq });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { update: mockUpdate } as any;
        }
        return {} as any;
      });

      // Update member status
      await supabase.from('members')
        .update({ status: 'ATIVO' })
        .eq('id', 'member-001');

      // Trigger should log old_value = 'LEAD', new_value = 'ATIVO'
      expect(mockUpdate).toHaveBeenCalledWith({ status: 'ATIVO' });
      // Audit log entry created by trigger with:
      // - action: 'UPDATE'
      // - old_value: { status: 'LEAD' }
      // - new_value: { status: 'ATIVO' }
    });

    it('trigger_audit_log: log member deletion', async () => {
      const mockEq = vi.fn().mockResolvedValue({
        data: null,
        error: null,
      });

      const mockDelete = vi.fn().mockReturnValue({ eq: mockEq });

      // Or soft delete via update
      const mockUpdate = vi.fn().mockReturnValue({ eq: mockEq });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { delete: mockDelete, update: mockUpdate } as any;
        }
        return {} as any;
      });

      // Soft delete (set ativo = false)
      await supabase.from('members')
        .update({ ativo: false })
        .eq('id', 'member-001');

      // Trigger should log deletion with old_value
      expect(mockUpdate).toHaveBeenCalled();
      // Audit log entry:
      // - action: 'DELETE'
      // - old_value: { entire member record }
    });
  });

  describe('Immutability Triggers', () => {
    it('trigger_immutable_check_in: prevent check-in modification', async () => {
      // Mock check-in insert
      const mockInsert = vi.fn().mockResolvedValue({
        data: {
          id: 'checkin-001',
          member_id: 'member-123',
          result: 'ALLOWED',
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'check_ins') {
          return { insert: mockInsert } as any;
        }
        return {} as any;
      });

      // Insert check-in
      await supabase.from('check_ins').insert({
        member_id: 'member-123',
        type: 'MEMBER',
        result: 'ALLOWED',
      });

      // Attempt to update check-in (should be prevented by trigger)
      const mockEq = vi.fn().mockResolvedValue({
        data: null,
        error: {
          message: 'Check-ins are immutable',
          code: '23514', // Check constraint violation
        },
      });

      const mockUpdate = vi.fn().mockReturnValue({ eq: mockEq });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'check_ins') {
          return { update: mockUpdate } as any;
        }
        return {} as any;
      });

      const { error } = await supabase
        .from('check_ins')
        .update({ result: 'BLOCKED' })
        .eq('id', 'checkin-001');

      // Verify error thrown by trigger
      expect(error).toBeDefined();
      expect(error?.message).toContain('immutable');
    });

    it('trigger_immutable_transaction: prevent transaction modification', async () => {
      // Mock transaction insert
      const mockInsert = vi.fn().mockResolvedValue({
        data: {
          id: 'txn-001',
          amount_cents: 6900,
        },
        error: null,
      });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'transactions') {
          return { insert: mockInsert } as any;
        }
        return {} as any;
      });

      await supabase.from('transactions').insert({
        type: 'RECEITA',
        category: 'SUBSCRIPTION',
        amount_cents: 6900,
        payment_method: 'DINHEIRO',
      });

      // Attempt to update amount (should fail)
      const mockEq = vi.fn().mockResolvedValue({
        data: null,
        error: {
          message: 'Transactions are immutable',
          code: '23514',
        },
      });

      const mockUpdate = vi.fn().mockReturnValue({ eq: mockEq });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'transactions') {
          return { update: mockUpdate } as any;
        }
        return {} as any;
      });

      const { error } = await supabase
        .from('transactions')
        .update({ amount_cents: 5000 })
        .eq('id', 'txn-001');

      expect(error).toBeDefined();
      expect(error?.message).toContain('immutable');
    });
  });

  describe('Unique QR Retry Logic', () => {
    it('QR generation: retry on collision until unique', async () => {
      const generatedQRs: string[] = [];

      // Mock QR generation with collision on first attempt
      const mockInsert = vi.fn()
        .mockResolvedValueOnce({
          data: null,
          error: {
            code: '23505', // Unique violation
            message: 'duplicate key value violates unique constraint',
          },
        })
        .mockResolvedValueOnce({
          data: {
            id: 'member-001',
            qr_code: 'MBR-XYZ12345', // Second attempt succeeds
          },
          error: null,
        });

      vi.mocked(supabase.from).mockImplementation((table) => {
        if (table === 'members') {
          return { insert: mockInsert } as any;
        }
        return {} as any;
      });

      // Insert member (trigger retries QR generation on collision)
      const { data, error } = await supabase.from('members').insert({
        nome: 'João Silva',
        telefone: '912345678',
      });

      // Should eventually succeed with unique QR
      // In real implementation, trigger retries until unique
      expect(mockInsert).toHaveBeenCalled();

      // Second attempt should succeed
      if (error?.code === '23505') {
        // Retry logic would generate new QR
        const retryResult = await supabase.from('members').insert({
          nome: 'João Silva',
          telefone: '912345678',
        });
        expect(retryResult.error).toBeNull();
        expect(retryResult.data?.qr_code).toMatch(/^MBR-[A-Z0-9]{8}$/);
      }
    });
  });
});
